
***IMPORTANT*** May not need a pointer to 
the children. May just need to maintain 
parent pointers.

MISC:

Why Can't I implement vertexcollection as 
a cpp map etc?

when deattaching and merging the tree, 
the order becomes inversed. Alternatives:
(1) keep the tree (????)
(2) new root for the tree
can be done in logn according to paper
Flip the pointers on the path from vertex to 
current root

change tree_insert order of arguments to 
something sane                                  [done]

change tree_insert to insert a vertexpointer
not a treevertexpointer. Should probably try
to minimize interaction with vertexpointer.     [done]

For the merge step, need to detach the strong
branch from the root and connect the tree 
using (s, w). To detach the strong branch, 
we need to 
(1) remove the pointer from s to root.
(2) romeve the pointer from root to s

To connect the tree using (s, w) we need to
(1) take the subtree s and insert it under w
using tree_insert.

LOGIC:

to remove something from edgecollection, it 
is not enough to use collection to remove.
We also need to update the indices map.

Get the branch which contains a particular
vertex                                          [done]
Have no such function in tree. Need to
implement it. However, I have a treevertex_get.
Just need to wrap it in tree.
*** IMPORTANT *** Need to take action with 
trees contains
structure. Is it needed for the algorithm? If 
I can delete it, it would mean a much simpler
tree. If not deleted, both make_tree and tree_get
is BROKEN.
I don't expcilitly need to check if a tree 
contains a vertex => can remove this 
functionality                                   [done]

TESTS:
initialize_pseudoflow                           [done]
merger_edge                                     [done]
tree_deattach                                   [done]

FUNCTIONS:

tree_set_root                                   []
for each vertex on the path from v to root:
(1) add parent(v) to children(v)
(2) remove v from children(parent)
(3) set parent(v) = null
(4) set parent(parent) = v
tree_path                                       []
initialize_pseudoflow_algorithm                 [done]
get_merger_edge()                               [done]
scan the residual edges. Each vertex in the tree
represents a vertex in the graph. The excess of 
each node is always updated and maintained. So
we need a 
    int *excess
pointer where we store that.

A vertex is strong if excess(T_ri) > 0 and weak
otherwise. Could initially create a function that 
scans the tree, for each vertex met, check the excess.
since the excess is maintained for ri by the algorithm,
we could quickly get a tuple of strong and weak vertices.

Now, we would like to find a residual edge that connects
these two sets S, W. Naive: Scan the residual edges. for an 
edge (u, v), check if u in S and v in W.

MISC:

save index together with edge in edgeset?
avoid get_index?                                []

push_relabel_network.{c,h}
I would like to use the network modules for the
next algorithm as well. Need to be careful what 
is native to push/relabel and not psuedoflow:
* network->active_vertices                      [done]
    - activate_vertices                         [done]
    - initialize
    - networkvertex_active
* network->distance_labels                      [done]
* network->is_reverse (?)                       [done]

Excesses depends on inflows/outflows, but it's
more general than exflow: instead of a single
vertex it's the flow difference of a vertex-set,
and the edges are the edges cut by the vertices

If functions in networkedge/networkvertex 
are completely for push_relabel, should move
to a new module                                 [done]

is_active(vertex) needs to be extended to
is_strong(vertexset) because the pseudoflow-
algorithm works on subtrees aka vertexsets      [done]

Then rename algorithms to push_relabel and      [done]
initialize a new module for psuedoflow          [done]

-----------------

timer in ./bin/main                             [done]
add constructs to allow for constant access     [done]
(do not need to generate res_graph etc)
clean up, sort network
change spit to accept a network

efficient maintanence of residual graph         [done]
remove, add max Ologn                           [done]

network store in_edges for each vertex          [done]

store the inflow and outflow of vertices        [done]

most time taken by vertex comparisons:          [done]
change vertexpointer to vertex?

need not flows of edges? enough with vertex     [done]
in/out flows?

better time remove                              [done]

store active vertices                           [done]
an active vertex is a vertex with exflow > 0
active vertex change = exflow change
exflow change = inflow, outflow change
inflow, outflow change only in add_flow 

instead of removing, I could add a guard to
make edges residual. residual edges are only
added and removed at two places. 
1. the initialization of the algorithm
2. when augmenting
At these places I could set a residual 
property to true/false

The residual edges are used at
1. find_min
2. networkedge_is_admissable
nowhere else.

Where do i iterate over residual edges?
* find_min
I could have a map is_residual that I check in  [done]
find_min
networkedge_admissable
turn out it's actually more expensive to check
this map, than to perform the remove explicitly.
aborting.

RENAMINGS:

set_* to replace*                               [done]
change variables of *collection to edges        [done]
change variables of *collection to vertices     [done]
array to collection                             [done]
edgeset to edgecollection                       [done]
vertexset to vertexcollection                   [done]

FUNCTIONS:

edgecollection_length                           [done]
vertexcollection_length                         [done]
array_length                                    [done]
exflow(vertex) = inflow - outflow               [done]
active(vertex) = exflow > 0                     [done]
distance_label(vertex)                          [done]
is_admissable(edge)                             [done]
network_residual                                ?
float residualal_capacity(networkedge)          [done]
network_edge_is_reverse                         [done]
networkvertex_distance_label                    [done]
edgecollection_remove                           [done]

TESTS FUNCTIONS:

graph_incident_with                             [done]
networkvertex_exflow                            [done]
network_active_vertex                           [done]
network_admissable_edge                         [] *
edgecollection_index_of                         [] * (needs to be the d+(v))
vertexcollection_index_of                       [] *
network_edge_is_residual                        [] *
edge_equals_reverse                             [] *
networkedge_augment                             [] *
networkvertex_set_distance_label                [done]
networkvertex_distance_label                    [done]
push_relabel                                    [] *
network_flow                                    []
graph_neighbours_of                             [] 
network_edge_is_reverse                         [done]

TESTS MODULES:

array.c                                         [done]
disjointset.c                                   [done]
edge.c                                          [done]
edgecollection.c                                [done]
graph.c                                         [done]
parser.c                                        [done]
spit.c                                          []
tokenizer.c                                     [done]
tokentable.c                                    [done]
tree.c                                          []
treevertex.c                                    []
util.c                                          []
vertex.c                                        [done]
vertexcollection.c                              []
network.c                                       []
main.c

