TESTS:
initialize_pseudoflow                           [done]

FUNCTIONS:

initialize_pseudoflow_algorithm                 [done]
get_merger_edge()                               []
scan the residual edges. Each vertex in the tree
represents a vertex in the graph. The excess of 
each node is always updated and maintained. So
we need a 
    int *excess
pointer where we store that.

A vertex is strong if excess(T_ri) > 0 and weak
otherwise. Could initially create a function that 
scans the tree, for each vertex met, check the excess.
since the excess is maintained for ri by the algorithm,
we could quickly get a tuple of strong and weak vertices.

Now, we would like to find a residual edge that connects
these two sets S, W. Naive: Scan the residual edges. for an 
edge (u, v), check if u in S and v in W.

MISC:

save index together with edge in edgeset?
avoid get_index?                                []

push_relabel_network.{c,h}
I would like to use the network modules for the
next algorithm as well. Need to be careful what 
is native to push/relabel and not psuedoflow:
* network->active_vertices                      [done]
    - activate_vertices                         [done]
    - initialize
    - networkvertex_active
* network->distance_labels                      [done]
* network->is_reverse (?)                       [done]

Excesses depends on inflows/outflows, but it's
more general than exflow: instead of a single
vertex it's the flow difference of a vertex-set,
and the edges are the edges cut by the vertices

If functions in networkedge/networkvertex 
are completely for push_relabel, should move
to a new module                                 [done]

is_active(vertex) needs to be extended to
is_strong(vertexset) because the pseudoflow-
algorithm works on subtrees aka vertexsets      [done]

Then rename algorithms to push_relabel and      [done]
initialize a new module for psuedoflow          [done]

-----------------

timer in ./bin/main                             [done]
add constructs to allow for constant access     [done]
(do not need to generate res_graph etc)
clean up, sort network
change spit to accept a network

efficient maintanence of residual graph         [done]
remove, add max Ologn                           [done]

network store in_edges for each vertex          [done]

store the inflow and outflow of vertices        [done]

most time taken by vertex comparisons:          [done]
change vertexpointer to vertex?

need not flows of edges? enough with vertex     [done]
in/out flows?

better time remove                              [done]

store active vertices                           [done]
an active vertex is a vertex with exflow > 0
active vertex change = exflow change
exflow change = inflow, outflow change
inflow, outflow change only in add_flow 

instead of removing, I could add a guard to
make edges residual. residual edges are only
added and removed at two places. 
1. the initialization of the algorithm
2. when augmenting
At these places I could set a residual 
property to true/false

The residual edges are used at
1. find_min
2. networkedge_is_admissable
nowhere else.

Where do i iterate over residual edges?
* find_min
I could have a map is_residual that I check in  [done]
find_min
networkedge_admissable
turn out it's actually more expensive to check
this map, than to perform the remove explicitly.
aborting.

RENAMINGS:

set_* to replace*                               [done]
change variables of *collection to edges        [done]
change variables of *collection to vertices     [done]
array to collection                             [done]
edgeset to edgecollection                       [done]
vertexset to vertexcollection                   [done]

FUNCTIONS:

edgecollection_length                           [done]
vertexcollection_length                         [done]
array_length                                    [done]
exflow(vertex) = inflow - outflow               [done]
active(vertex) = exflow > 0                     [done]
distance_label(vertex)                          [done]
is_admissable(edge)                             [done]
network_residual                                ?
float residualal_capacity(networkedge)          [done]
network_edge_is_reverse                         [done]
networkvertex_distance_label                    [done]
edgecollection_remove                           [done]

TESTS FUNCTIONS:

graph_incident_with                             [done]
networkvertex_exflow                            [done]
network_active_vertex                           [done]
network_admissable_edge                         [] *
edgecollection_index_of                         [] * (needs to be the d+(v))
vertexcollection_index_of                       [] *
network_edge_is_residual                        [] *
edge_equals_reverse                             [] *
networkedge_augment                             [] *
networkvertex_set_distance_label                [done]
networkvertex_distance_label                    [done]
push_relabel                                    [] *
network_flow                                    []
graph_neighbours_of                             [] 
network_edge_is_reverse                         [done]

TESTS MODULES:

array.c                                         [done]
disjointset.c                                   [done]
edge.c                                          [done]
edgecollection.c                                [done]
graph.c                                         [done]
parser.c                                        [done]
spit.c                                          []
tokenizer.c                                     [done]
tokentable.c                                    [done]
tree.c                                          []
treevertex.c                                    []
util.c                                          []
vertex.c                                        [done]
vertexcollection.c                              []
network.c                                       []
main.c

